# 6. Implementation and Testing (6.1)

This document summarizes the implementation and testing approach used for the Trash2Cash system. The write-up is intentionally non-technical so it can be presented easily to stakeholders and reviewers.

## Implementation Overview

- Purpose: Convert the proposed design into a working system that enables QR-based, camera-assisted waste disposal and a simple rewards program.
- Approach: Incremental, pragmatic development focused on getting a reliable end-to-end flow working first (QR → session → capture → inference → bin control → reward). The team built a minimum viable system and then iterated to improve reliability and user experience.
- Roles: The implementation focused on three visible roles: (1) user-facing mobile and kiosk interactions; (2) backend coordination and business rules (sessions, records, points); (3) device integration for camera capture and actuator control.

## Development Methods and Tools (high-level)

- Methods: Agile-style incremental development with short cycles, frequent checks, and small, testable changes. Emphasis was placed on reproducible deployments and predictable behavior in local network (edge) environments.
- Tools: Standard project tools were used for coding, package management, and version control. Tools were selected to support maintainability and to keep the system easy to explain and hand off.
- Controlled libraries & templates: The project used a small set of well-known, maintained libraries to reduce risk. Templates and UI patterns were kept simple and consistent to ease user training and reduce support overhead.

## Testing Methodology (non-technical)

- Strategy: A layered testing strategy was used — verify each major step independently (QR handling, camera capture, classification decision, actuator control) and then run end-to-end tests that exercise the whole flow.
- Types of tests:
  - Manual functional tests: real users (or developers acting as users) validated the flows on mobile and kiosk setups.
  - Integration checks: the team confirmed that the backend, camera, and bin controller work together in the field-like network environment.
  - Regression checks: after any change, core flows were retested to avoid introducing failures.
- Acceptance criteria: A disposal flow was considered acceptable when a QR-authenticated session could reliably lead to a captured image, a model decision, a bin actuator command, and a persistent record with awarded points.

## Core Functionalities (narrative)

- QR Authentication & Session: The user shows a QR (generated by the mobile app) at a kiosk or scanner. The system validates the QR and creates a short-lived session bound to a specific bin.
- Capture & Classify: While the session is active, the backend obtains a camera frame and runs a classification step to determine the waste type (paper/plastic/glass/metal). The system uses a conservative acceptance policy and falls back to safe behavior when confidence is low.
- Bin Control & Confirmation: Once a decision is reached, the backend instructs the bin controller to open the correct compartment and then awaits confirmation. The system records the event and awards points to the user's account.
- Rewards & History: Each successful disposal yields points. Users can view their history and redeem rewards through the application interface.

## How the System Was Evaluated Against Requirements

- Correctness: The team verified that each functional requirement (QR scanning, session management, classification, actuator control, record persistence) is present and exercised by tests or demonstrations.
- Reliability: The system was tested in local network scenarios similar to the intended deployment. Testing focused on ensuring sessions time out correctly, devices recover from temporary network losses, and the system avoids duplicate point awards.
- Usability: User-facing screens were tested for clarity and minimal steps. The QR flow was measured for simplicity (scan → visible confirmation → disposal) rather than raw speed.

## Accuracy, Performance, and Scalability — High-level Analysis

- Accuracy: The classification model used in the system was selected for a good trade-off between size and accuracy so it can operate in a constrained environment. The system applies confidence thresholds and conservative fallbacks to avoid incorrect routing of waste.
- Performance: The design prioritizes predictability and short response times (capture and decision within a few seconds). In practice, network latency and device responsiveness are the main sources of delay; these were measured during integration and tuned where practical.
- Scalability: The current implementation is suitable for small to medium deployments (a few bins and local backend). The architecture allows horizontal scaling (separating inference, adding message queues, and moving to a production database) if fleet size or load increases.

## Limitations and Mitigations

- Domain gap: Models trained on public datasets may not perform identically on live camera feeds. Mitigation: collect a small in-field dataset and fine-tune the model before wider rollout.
- Network dependency: Devices working on local APs may be unreachable from cloud services. Mitigation: the system is designed for local-first operation and uses short-lived sessions to reduce risk.
- Hardware variability: Different bins and motors may behave differently in the field. Mitigation: document per-device calibration steps and provide a manual override for administrators.

## Deployment and Maintenance (recommended, optional)

- Deployment: Package the backend in a reproducible form and deploy it on a local machine or small server near the bins. Prefer simple containerization for repeatability, and document the steps for local deployments.
- Maintenance: Maintain a small checklist for on-site teams: ensure device power/network, verify camera alignment, update model artifacts when improved datasets are available, and monitor logs for repeated failures.

## Software Quality (recommended, optional)

- Functional quality: The system focuses on delivering specified user-facing behaviors (secure QR sessions, reliable capture, conservative classification, and deterministic bin control).
- Structural quality: To promote maintainability, the codebase keeps interfaces between components small and clear, uses a small set of dependencies, and documents major assumptions (e.g., local network topology).

## Summary

The implementation emphasizes a practical, minimally complex system that meets the problem statement: enabling QR-authenticated, camera-assisted disposal with auditable rewards. Testing focused on the core end-to-end flow with conservative fallbacks for real-world variability. The design is ready for incremental improvements (field data collection, model fine-tuning, and scaled deployment) while remaining easy to explain and maintain.
